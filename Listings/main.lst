C51 COMPILER V9.00   MAIN                                                                  06/20/2015 22:18:00 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE source\main.c RTX51 OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\Lis
                    -tings\main.lst) OBJECT(.\Objects\main.obj)

line level    source

   1          
   2          /***************
   3          项目名称：电动车充电器控制器
   4          功能：    根据电池电量的不同合理控制充电电流，保护电池寿命。
   5          作者：    河南科技大学----黄永全
   6          日期：    2015/06/04
   7          **************/
   8          /**************头文件**************/
   9          #include <STC15F2K60S2.H>
  10          #include "main.h"
  11          #include "stdio.h"
  12          #include "adc.h"
  13          #include "led.h"
  14          #include "key.h"
  15          #include "pwm_dac.h"
  16          #include "time.h"
  17          #include "delay.h"
  18          #include "usart.h"
  19          #include "eeprom.h"
  20          
  21          /***********系统变量定义**********/
  22          WORD Time_Base = 0;//系统时基
  23          SYSTime SYS_Time;  //系统时钟
  24          BYTE SYS_STEP = 1; //系统执行的步骤
  25          u16 AD_Time = 0;
  26          u16 AD = 1023;    //采集回来的AD值
  27          u16 AD0 = 1023;   //异常情况采集
  28          BYTE DA = 10;      
  29          //BYTE CurrentBase[6] = {0x00,0x80,0x67,0x33,0x19,0};//0\2.5\2.0\1.0\0.5 电流基准
  30          //BYTE VoltageBase[6] = {0x00,0x9a,0xce,0xce,0xb4,0};//0\3\4\4\3.5       电压基准
  31          //WORD CurrentInput[6] = {0x00,0x019f,0x00d1,0x006a,0,0};//0\2\1\0.5\      电流输入信号
  32          BYTE CurrentBase[6] = {0x00,0x9a,0x80,0x4d,0x19,0};//0\3\2.5\1.5\1 电流基准
  33          BYTE VoltageBase[6] = {0x00,0xb8,0xce,0xce,0xb8,0};//0\3.6\4\4\3.6       电压基准
  34          WORD CurrentInput[6] = {0x00,0x0200,0x010a,0x00d1,0,0};//0\2.5\1.3\1.0\   电流输入信号
  35          BYTE Current_Base = 0;
  36          BYTE Voltage_Base = 0;
  37          BYTE Change_Num = 0; //选择参数项
  38          BYTE Wait_Flag = 0;
  39          BYTE Save_Flag = 0;//存储数据的标志
  40          BYTE Warrning_Flag = 0;//存储数据的标志
  41          u16 time_wait =0;
  42          u8  Current_Time = 0;
  43          
  44          void user_app()//用户程序
  45          {
  46   1          u8 key_stateValue;  
  47   1          u8* pKeyValue;  
  48   1          *pKeyValue=0;  
  49   1          key_stateValue=read_key(pKeyValue); 
  50   1      //      if(Key_Lock==1)//锁定键，为1解除锁定，为0锁定
  51   1      //      {
  52   1                      if((*pKeyValue==4)&&(key_stateValue == return_keyPressed) )//调试按键
  53   1                      {
  54   2                              SYS_STEP++;
C51 COMPILER V9.00   MAIN                                                                  06/20/2015 22:18:00 PAGE 2   

  55   2                              if(SYS_STEP>5) 
  56   2                              {
  57   3                                      SYS_STEP = 1;
  58   3                              }
  59   2                                      
  60   2                      }
  61   1                      if((*pKeyValue==3)&&(key_stateValue == return_keyPressed) )//参数选择按键
  62   1                      {
  63   2                              Change_Num++;
  64   2                              if(Change_Num>3) 
  65   2                              {
  66   3                                      Save_Flag = 1;  //开始保存数据
  67   3                                      Change_Num = 0;
  68   3                              }
  69   2                                      
  70   2                      }
  71   1                      if((key_stateValue == return_keyPressed)||(key_stateValue & return_keyAuto) )//长按键加连发
  72   1                      {
  73   2                              if((*pKeyValue==UP)&&(Change_Num!=0))
  74   2                              {
  75   3                                      switch(Change_Num)
  76   3                                      {
  77   4                                              case 1:CurrentBase[SYS_STEP]++;
  78   4                      
  79   4                                                         break;
  80   4                                              case 2:VoltageBase[SYS_STEP]++;
  81   4                                                      
  82   4                                                         break;
  83   4                                              case 3:CurrentInput[SYS_STEP]++;
  84   4                                                         
  85   4                                                              break;
  86   4      
  87   4                                      }
  88   3                              }
  89   2                              if((*pKeyValue==DOWN)&&(Change_Num!=0))
  90   2                              {
  91   3                                      switch(Change_Num)
  92   3                                      {
  93   4                                              case 1:CurrentBase[SYS_STEP]--;break;
  94   4                                              case 2:VoltageBase[SYS_STEP]--;break;
  95   4                                              case 3:CurrentInput[SYS_STEP]--;break;
  96   4                                                              
  97   4                                                      
  98   4                                      }
  99   3                              }
 100   2      
 101   2                      }
 102   1      //      }
 103   1              
 104   1              
 105   1              
 106   1      }
 107          void UserData_Claculite()//用户数据分析，判断该执行第几步
 108          {
 109   1              
 110   1              if( (AD<= CurrentInput[SYS_STEP])&&(SYS_STEP < 4))//如果电流输入信号低于2.0V并且超过10S,前3步执行，
 111   1              {
 112   2      //              if(AD <= 0x2c)//如果电流输入信号低于0.2V暂停计时
 113   2      //              {
 114   2      //                      Delay_nms(100);
 115   2      //                      while(Get_ad_result(5)<=0x2c)
 116   2      //                      {
C51 COMPILER V9.00   MAIN                                                                  06/20/2015 22:18:00 PAGE 3   

 117   2      //                              TR0 = 0;//暂停计时器
 118   2      //                              LedShanShuo();
 119   2      //                      }
 120   2      //                      TR0 = 1;//打开计时器
 121   2      //              }
 122   2      //              else
 123   2      //              {
 124   2                              Wait_Flag = 1;
 125   2                              if(time_wait>=1000)//超过10S
 126   2                              {               
 127   3                                      SYS_STEP++;//转到下一步 
 128   3                                      Wait_Flag = 0;
 129   3                                      time_wait = 0;
 130   3                                      Led0 = 0;
 131   3                                      if(SYS_STEP == 2)SYS_Time.GHour = 6;//将时间设置到第二阶段的时间6~9小时 
 132   3                                      if(SYS_STEP == 3)SYS_Time.GHour = 9;//将时间设置到第二阶段的时间6~9小时 
 133   3                                      if(SYS_STEP == 4)SYS_Time.GHour = 12;//将时间设置到第二阶段的时间6~9小时 
 134   3                              }
 135   2                              if(time_wait>=50)//检测10次防止错误检测
 136   2                              {
 137   3                                      Led0 = 1;
 138   3                                      
 139   3                              }
 140   2      //              }
 141   2                      
 142   2                                                              
 143   2              }
 144   1              else
 145   1              {
 146   2                      Wait_Flag = 0;//关闭等待计时
 147   2                      time_wait = 0;
 148   2                      Led0 = 0;
 149   2              }
 150   1      
 151   1              if(AD0 <= 615)//如果电流输入信号低于3V暂停计时 0x0267
 152   1              {
 153   2                      Delay_nms(100);
 154   2                      while(Get_ad_result(5)<=0x2c)
 155   2                      {
 156   3                              TR0 = 0;//暂停计时器
 157   3                              LedShanShuo();
 158   3                      }
 159   2                      TR0 = 1;//打开计时器
 160   2              }
 161   1              
 162   1      }
 163          void main()
 164          {
 165   1          Key_Init();
 166   1              InitUart();
 167   1              LedPortInit();
 168   1              Timer0Init();
 169   1              AD_init();
 170   1              PWMn_init();
 171   1          while(UserData_Init()) LedShanShuo();
 172   1              EA = 1;
 173   1              Delay_nms(1000);
 174   1              while(1)
 175   1              {
 176   2      //              EA = 1;
 177   2      //              TR0 = 1;
 178   2                      AD = Get_ad_result(5);
C51 COMPILER V9.00   MAIN                                                                  06/20/2015 22:18:00 PAGE 4   

 179   2                      AD0 = Get_ad_result(2);
 180   2                      UserData_Claculite();
 181   2                      if(Change_Num) Current_Time = 0;//此句是为了在修正是数据输出口不反转用的
 182   2                      switch(SYS_STEP)// 整个系统执行流程
 183   2                      {
 184   3                              case 1://第一阶段 0 ~ 6小时 
 185   3                              {
 186   4                                      
 187   4                                      if(Current_Time<30)//30秒2.5V
 188   4                                      {
 189   5                                              PWM0_set (0,CurrentBase[SYS_STEP]);
 190   5                                              
 191   5                                      }
 192   4                                      else if(Current_Time<35)
 193   4                                              {
 194   5                                                      PWM0_set (0,0x33);//5秒1V
 195   5                                              }
 196   4                                              else
 197   4                                              {
 198   5                                                      Current_Time = 0;
 199   5                                              }
 200   4                                      PWM0_set (1,VoltageBase[SYS_STEP]);
 201   4                                      if(Change_Num==0)//避免和用户调节是的指示灯互相干扰
 202   4                                      {
 203   5                                              Led1 = 1;
 204   5                                              Led2 = 0;
 205   5                                              Led3 = 0;
 206   5                                      }
 207   4                                      
 208   4                                      if(SYS_Time.GHour==6)SYS_STEP++;// 时间到转到下一步                             
 209   4                                      break;
 210   4                              }
 211   3                              case 2://第一阶段 6 ~ 9小时 
 212   3                              {
 213   4                                      if(Current_Time<30)//30秒2.5V
 214   4                                      {
 215   5                                              PWM0_set (0,CurrentBase[SYS_STEP]);
 216   5                                              
 217   5                                      }
 218   4                                      else if(Current_Time<35)
 219   4                                              {
 220   5                                                      PWM0_set (0,0x33);//5秒1V
 221   5                                              }
 222   4                                              else
 223   4                                              {
 224   5                                                      Current_Time = 0;
 225   5                                              }
 226   4                                      PWM0_set (1,VoltageBase[SYS_STEP]);
 227   4                                      if(Change_Num==0)//避免和用户调节是的指示灯互相干扰
 228   4                                      {
 229   5                                              Led1 = 0;
 230   5                                              Led2 = 1;
 231   5                                              Led3 = 0;
 232   5                                      }
 233   4                                      if(SYS_Time.GHour==9)SYS_STEP++;
 234   4                                      break;
 235   4                              }                       
 236   3                              case 3://第一阶段 9 ~ 12小时 
 237   3                              {
 238   4                                      if(Current_Time<30)//30秒2.5V
 239   4                                      {
 240   5                                              PWM0_set (0,CurrentBase[SYS_STEP]);
C51 COMPILER V9.00   MAIN                                                                  06/20/2015 22:18:00 PAGE 5   

 241   5                                              
 242   5                                      }
 243   4                                      else if(Current_Time<35)
 244   4                                              {
 245   5                                                      PWM0_set (0,0x19);//5秒0.5V
 246   5                                              }
 247   4                                              else
 248   4                                              {
 249   5                                                      Current_Time = 0;
 250   5                                              }
 251   4                                      PWM0_set (1,VoltageBase[SYS_STEP]);
 252   4                                      if(Change_Num==0)//避免和用户调节是的指示灯互相干扰
 253   4                                      {
 254   5                                              Led1 = 0;
 255   5                                              Led2 = 0;
 256   5                                              Led3 = 1;
 257   5                                      }
 258   4                                      if(SYS_Time.GHour==12)SYS_STEP++;// 时间到转到下一步    
 259   4                                      break;
 260   4                              }
 261   3                              case 4://第一阶段 12 ~ 14小时 
 262   3                              {
 263   4                                      PWM0_set (0,CurrentBase[SYS_STEP]);
 264   4                                      PWM0_set (1,VoltageBase[SYS_STEP]);
 265   4                                      if(Change_Num==0)//避免和用户调节是的指示灯互相干扰
 266   4                                      {
 267   5                                              Led1 = 0;
 268   5                                              Led2 = 0;
 269   5                                              Led3 = 0;
 270   5                                      }
 271   4                                      if(SYS_Time.GHour==14)SYS_STEP++;// 时间到转到下一步    
 272   4                                      break;
 273   4                              }
 274   3                              case 5://充满
 275   3                              {
 276   4                                      PWM0_set (0,CurrentBase[0]);
 277   4                                      PWM0_set (1,VoltageBase[0]);
 278   4                                      if(Change_Num==0)//避免和用户调节是的指示灯互相干扰
 279   4                                      {
 280   5                                              Led1 = 0;
 281   5                                              Led2 = 0;
 282   5                                              Led3 = 0;
 283   5                                      }
 284   4      //                              SYS_STEP = 1;
 285   4                                      break;
 286   4                              }
 287   3                      }
 288   2                      switch(Change_Num)
 289   2                      {
 290   3                              case 1:LedShanShuo1();break;
 291   3                              case 2:LedShanShuo2();break;
 292   3                              case 3:LedShanShuo3();break;
 293   3                              case 0:  break;
 294   3                      }
 295   2                      if(Save_Flag == 1)
 296   2                      {
 297   3                              Save_Flag = 0;
 298   3                              UserData_Init0();
 299   3                              LedShanShuo();
 300   3                      }
 301   2                                      
 302   2                      Delay_nms(10);
C51 COMPILER V9.00   MAIN                                                                  06/20/2015 22:18:00 PAGE 6   

 303   2                      
 304   2              }
 305   1      
 306   1      }
 307          //-----------------------------------------------
 308          
 309          /* Timer0 interrupt routine */
 310          void tm0_isr() interrupt 1 using 1
 311          {
 312   1              TL0 = T0MS;                     //初始化计时值
 313   1          TH0 = T0MS >> 8;
 314   1              Time_Base++;
 315   1              if(Time_Base>=100)
 316   1              {
 317   2                      Time_Base = 0;
 318   2                      Current_Time++;//用于输出口1 30秒和5秒重复用
 319   2                      SYS_Time.GSeconds++;
 320   2                      if(SYS_Time.GSeconds>59) 
 321   2                      {
 322   3                              SYS_Time.GSeconds=0;
 323   3                              SYS_Time.GMintes++;
 324   3                      }
 325   2                      if(SYS_Time.GMintes>59) 
 326   2                      {
 327   3                              SYS_Time.GMintes=0;
 328   3                              SYS_Time.GHour++;
 329   3                      }
 330   2                      if(SYS_Time.GHour>23) 
 331   2                      {
 332   3                              SYS_Time.GHour=0;
 333   3                      }
 334   2      
 335   2              }
 336   1              if(Wait_Flag)time_wait++;//执行周期为10ms       
 337   1              user_app();                      
 338   1      }
 339          /*----------------------------
 340          UART interrupt service routine
 341          ----------------------------*/
 342          void Uart_Isr() interrupt 4 using 1
 343          {
 344   1          if (RI)
 345   1          {
 346   2              RI = 0;             //Clear receive interrupt flag
 347   2              DA = SBUF; 
 348   2      //              SendData(DA);
 349   2      //              PWM0_set (0,DA);
 350   2      //              PWM0_set (1,DA); 
 351   2                      if(DA == 0xaa)
 352   2                      {
 353   3                              IapEraseSector(0x0000);//擦出第一个扇区
 354   3                              IapEraseSector(0x0200);//擦出第二个扇区
 355   3                      }
 356   2                      if(DA == 1)
 357   2                      {
 358   3                              SendData(CurrentBase[SYS_STEP]);
 359   3                              SendData(VoltageBase[SYS_STEP]);
 360   3                              SendData(CurrentInput[SYS_STEP]>>8);
 361   3                              SendData(CurrentInput[SYS_STEP]&0xff);
 362   3                      }
 363   2                      if(DA == 2)
 364   2                      {
C51 COMPILER V9.00   MAIN                                                                  06/20/2015 22:18:00 PAGE 7   

 365   3                              SendData(AD>>8);
 366   3                              SendData(AD);
 367   3                      }
 368   2                      if(DA == 3)
 369   2                      {
 370   3                              SendData(SYS_Time.GHour);
 371   3                              SendData(SYS_Time.GMintes);
 372   3                              SendData(SYS_Time.GSeconds);
 373   3                      }
 374   2          }
 375   1      }
 376           WORD Get_SYSTime()
 377          {
 378   1              return Time_Base;
 379   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    989    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     46       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
