C51 COMPILER V9.00   EEPROM                                                                06/10/2015 21:32:44 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE EEPROM
OBJECT MODULE PLACED IN .\Objects\eeprom.obj
COMPILER INVOKED BY: C:\Keil\C51\BIN\C51.EXE source\eeprom.c RTX51 OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECTEXTEND PRINT(.\L
                    -istings\eeprom.lst) OBJECT(.\Objects\eeprom.obj)

line level    source

   1          #include "main.h"
   2          #include "eeprom.h"
   3          #include "usart.h"
   4          #include "led.h"
   5          #define  USE_TIME  10
   6          
   7          #define CMD_IDLE    0               //ç©ºé—²æ¨¡å¼
   8          #define CMD_READ    1               //IAPå­—èŠ‚è¯»å‘½ä»¤
   9          #define CMD_PROGRAM 2               //IAPå­—èŠ‚ç¼–ç¨‹å‘½ä»¤
  10          #define CMD_ERASE   3               //IAPæ‰‡åŒºæ“¦é™¤å‘½ä»¤
  11          
  12          //#define ENABLE_IAP 0x80           //if SYSCLK<30MHz
  13          //#define ENABLE_IAP 0x81           //if SYSCLK<24MHz
  14          #define ENABLE_IAP  0x82            //if SYSCLK<20MHz
  15          //#define ENABLE_IAP 0x83           //if SYSCLK<12MHz
  16          //#define ENABLE_IAP 0x84           //if SYSCLK<6MHz
  17          //#define ENABLE_IAP 0x85           //if SYSCLK<3MHz
  18          //#define ENABLE_IAP 0x86           //if SYSCLK<2MHz
  19          //#define ENABLE_IAP 0x87           //if SYSCLK<1MHz
  20          
  21          
  22          /*
  23          0x00 -- 0x1ff
  24          0x200 -- 0x3ff
  25          0x400 -- 0x5ff
  26          0x600 -- 0x7ff
  27          0x800 -- 0x9ff
  28          :
  29          :
  30                   0x23ff
  31          */
  32          /*----------------------------
  33          è½¯ä»¶å»¶æ—¶
  34          ----------------------------*/
  35          void Delay(BYTE n)
  36          {
  37   1          WORD x;
  38   1      
  39   1          while (n--)
  40   1          {
  41   2              x = 0;
  42   2              while (++x);
  43   2          }
  44   1      }
  45          
  46          /*----------------------------
  47          å…³é—­IAP
  48          ----------------------------*/
  49          void IapIdle()
  50          {
  51   1          IAP_CONTR = 0;                  //å…³é—­IAPåŠŸèƒ½
  52   1          IAP_CMD = 0;                    //æ¸…é™¤å‘½ä»¤å¯„å­˜å™¨
  53   1          IAP_TRIG = 0;                   //æ¸…é™¤è§¦å‘å¯„å­˜å™¨
  54   1          IAP_ADDRH = 0x80;               //å°†åœ°å€è®¾ç½®åˆ°éIAPåŒºåŸŸ
C51 COMPILER V9.00   EEPROM                                                                06/10/2015 21:32:44 PAGE 2   

  55   1          IAP_ADDRL = 0;
  56   1      }
  57          
  58          /*----------------------------
  59          ä»ISP/IAP/EEPROMåŒºåŸŸè¯»å–ä¸€å­—èŠ‚
  60          ----------------------------*/
  61          BYTE IapReadByte(WORD addr)
  62          {
  63   1          BYTE dat;                       //æ•°æ®ç¼“å†²åŒº
  64   1          EA = 0;
  65   1          IAP_CONTR = ENABLE_IAP;         //ä½¿èƒ½IAP
  66   1          IAP_CMD = CMD_READ;             //è®¾ç½®IAPå‘½ä»¤
  67   1          IAP_ADDRL = addr;               //è®¾ç½®IAPä½åœ°å€
  68   1          IAP_ADDRH = addr >> 8;          //è®¾ç½®IAPé«˜åœ°å€
  69   1          IAP_TRIG = 0x5a;                //å†™è§¦å‘å‘½ä»¤(0x5a)
  70   1          IAP_TRIG = 0xa5;                //å†™è§¦å‘å‘½ä»¤(0xa5)
  71   1          _nop_();                        //ç­‰å¾…ISP/IAP/EEPROMæ“ä½œå®Œæˆ
  72   1          dat = IAP_DATA;                 //è¯»ISP/IAP/EEPROMæ•°æ®
  73   1          IapIdle();                      //å…³é—­IAPåŠŸèƒ½
  74   1              EA = 1;
  75   1          return dat;                     //è¿”å›
  76   1              
  77   1      }
  78          
  79          /*----------------------------
  80          å†™ä¸€å­—èŠ‚æ•°æ®åˆ°ISP/IAP/EEPROMåŒºåŸŸ
  81          ----------------------------*/
  82          void IapProgramByte(WORD addr, BYTE dat)
  83          {
  84   1              EA = 0;
  85   1          IAP_CONTR = ENABLE_IAP;         //ä½¿èƒ½IAP
  86   1          IAP_CMD = CMD_PROGRAM;          //è®¾ç½®IAPå‘½ä»¤
  87   1          IAP_ADDRL = addr;               //è®¾ç½®IAPä½åœ°å€
  88   1          IAP_ADDRH = addr >> 8;          //è®¾ç½®IAPé«˜åœ°å€
  89   1          IAP_DATA = dat;                 //å†™ISP/IAP/EEPROMæ•°æ®
  90   1          IAP_TRIG = 0x5a;                //å†™è§¦å‘å‘½ä»¤(0x5a)
  91   1          IAP_TRIG = 0xa5;                //å†™è§¦å‘å‘½ä»¤(0xa5)
  92   1          _nop_();                        //ç­‰å¾…ISP/IAP/EEPROMæ“ä½œå®Œæˆ
  93   1          IapIdle();
  94   1              EA = 1;
  95   1      }
  96          
  97          /*----------------------------
  98          æ‰‡åŒºæ“¦é™¤
  99          ----------------------------*/
 100          void IapEraseSector(WORD addr)
 101          {
 102   1              EA = 0;
 103   1          IAP_CONTR = ENABLE_IAP;         //ä½¿èƒ½IAP
 104   1          IAP_CMD = CMD_ERASE;            //è®¾ç½®IAPå‘½ä»¤
 105   1          IAP_ADDRL = addr;               //è®¾ç½®IAPä½åœ°å€
 106   1          IAP_ADDRH = addr >> 8;          //è®¾ç½®IAPé«˜åœ°å€
 107   1          IAP_TRIG = 0x5a;                //å†™è§¦å‘å‘½ä»¤(0x5a)
 108   1          IAP_TRIG = 0xa5;                //å†™è§¦å‘å‘½ä»¤(0xa5)
 109   1          _nop_();                        //ç­‰å¾…ISP/IAP/EEPROMæ“ä½œå®Œæˆ
 110   1          IapIdle();
 111   1              EA = 1;
 112   1      }
 113          BYTE UserData_Init0()//ç”¨äºç³»ç»Ÿä¸ªåˆå§‹åŒ–ï¼Œå‚æ•°è¿˜æ²¡æœ‰å¯¼å…¥çš„æ—¶å€™
 114          {
 115   1              char i = 0;
 116   1              IapEraseSector(0x0000);
C51 COMPILER V9.00   EEPROM                                                                06/10/2015 21:32:44 PAGE 3   

 117   1              for (i=1; i<5; i++)          
 118   1          {
 119   2                      IapProgramByte(Init_Flag+i,0x55);
 120   2              if (SendData(IapReadByte(i)) != 0x55)
 121   2                  return 1;             
 122   2          } 
 123   1                      IapEraseSector(0x0200);//æ“¦å‡ºç¬¬äºŒæ‰‡åŒºï¼Œå†™ä¹‹å‰å¿…é¡»æ“¦å‡º
 124   1                      for(i=0;i<6;i++)
 125   1                      {
 126   2                              IapProgramByte(Data1+i,CurrentBase[i]);
 127   2                              IapProgramByte(Data2+i,VoltageBase[i]);
 128   2                              IapProgramByte(Data3+2*i,(BYTE)((CurrentInput[i]>>8)&0xff));
 129   2                              IapProgramByte(Data3+2*i+1,(BYTE)(CurrentInput[i]&0xff));
 130   2                              
 131   2                      }
 132   1                      for(i=0;i<6;i++)
 133   1                      {
 134   2                              if(IapReadByte(Data1+i) != CurrentBase[i]) return 1;
 135   2                              SendData(IapReadByte(Data1+i));
 136   2                              if(IapReadByte(Data2+i) != VoltageBase[i]) return 1;
 137   2                              SendData(IapReadByte(Data2+i));
 138   2                              if(IapReadByte(Data3+2*i) != (BYTE)((CurrentInput[i]>>8)&0xff)) return 1;
 139   2                              SendData(IapReadByte(Data3+2*i));
 140   2                              if(IapReadByte(Data3+2*i+1) != (BYTE)(CurrentInput[i]&0xff)) return 1;
 141   2                              SendData(IapReadByte(Data3+2*i+1));
 142   2                      }
 143   1                      IapProgramByte(Init_Flag+0,0xaa);
 144   1                      SendData(IapReadByte(Init_Flag+0));
 145   1              return 0;
 146   1      }
 147          /*----------------------------
 148          åˆå§‹åŒ–ç”¨æˆ·å‚æ•°
 149          æ­£ç¡®è¿”å›0
 150          é”™è¯¯è¿”å›1
 151          ----------------------------*/
 152          BYTE UserData_Init()//ç”¨äºæ£€éªŒeepromæ˜¯å¦æ­£å¸¸å·¥ä½œçš„ä½œç”¨
 153          {
 154   1              u8 i = 0;
 155   1      //      IapEraseSector(0x0000);
 156   1              for (i=1; i<5; i++)          
 157   1          {
 158   2                      IapProgramByte(Init_Flag+i,0x55);
 159   2              if (SendData(IapReadByte(i)) != 0x55)
 160   2                  return 1;             
 161   2          }
 162   1              if (SendData(IapReadByte(0)) != 0xaa)
 163   1              {  
 164   2                      IapEraseSector(0x0200);//æ“¦å‡ºç¬¬äºŒæ‰‡åŒºï¼Œå†™ä¹‹å‰å¿…é¡»æ“¦å‡º
 165   2                      for(i=0;i<6;i++)
 166   2                      {
 167   3                              IapProgramByte(Data1+i,CurrentBase[i]);
 168   3                              IapProgramByte(Data2+i,VoltageBase[i]);
 169   3                              IapProgramByte(Data3+2*i,(BYTE)((CurrentInput[i]>>8)&0xff));
 170   3                              IapProgramByte(Data3+2*i+1,(BYTE)(CurrentInput[i]&0xff));
 171   3                              
 172   3                      }
 173   2                      for(i=0;i<6;i++)
 174   2                      {
 175   3                              if(IapReadByte(Data1+i) != CurrentBase[i]) return 1;
 176   3                              SendData(IapReadByte(Data1+i));
 177   3                              if(IapReadByte(Data2+i) != VoltageBase[i]) return 1;
 178   3                              SendData(IapReadByte(Data2+i));
C51 COMPILER V9.00   EEPROM                                                                06/10/2015 21:32:44 PAGE 4   

 179   3                              if(IapReadByte(Data3+2*i) != (BYTE)((CurrentInput[i]>>8)&0xff)) return 1;
 180   3                              SendData(IapReadByte(Data3+2*i));
 181   3                              if(IapReadByte(Data3+2*i+1) != (BYTE)(CurrentInput[i]&0xff)) return 1;
 182   3                              SendData(IapReadByte(Data3+2*i+1));
 183   3                      }
 184   2                      IapProgramByte(Init_Flag+0,0xaa);
 185   2                      SendData(IapReadByte(Init_Flag+0));
 186   2              }
 187   1              else
 188   1              {
 189   2                      for(i=0;i<6;i++)//ä»å†…å­˜ä¸­è·å–æ•°æ®
 190   2                      {
 191   3                              CurrentBase[i] = IapReadByte(Data1+i);//è¯»å–ç”µå…­åŸºå‡†å€¼ã€‚
 192   3                              SendData(CurrentBase[i]);
 193   3                              VoltageBase[i] = IapReadByte(Data2+i);//è¯»å‡ºç”µå‹åŸºå‡†å€¼ã€‚
 194   3                              SendData(VoltageBase[i]);
 195   3                              CurrentInput[i] = SendData(IapReadByte(Data3+2*i))<<8|SendData(IapReadByte(Data3+2*i+1));;//è¯»å‡ºç”µæµ
             -ä¿¡å·è¾“å…¥é˜ˆå€¼ã€‚
 196   3      //                      SendData(CurrentInput[i]>>8);SendData(CurrentInput[i]&0xff);
 197   3                      }
 198   2              }
 199   1              return 0;
 200   1      }
 201          void BUG()//ä½¿ç”¨æ—¶é•¿
 202          {
 203   1              if(SYS_Time.GHour>=10)
 204   1              while(1)
 205   1              {
 206   2                      LedShanShuo();
 207   2              }
 208   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1070    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       2
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
